#include <cmath> 
#include <vector>

#include "CollisionDetection.h"
#include "Engine/Physics/sRigidBodyState.h"
#include "Engine/Physics/CollisionPair.h"
#include "Engine/GameCommon/GameObject.h"
#include "Engine/Math/cMatrix_transformation.h"
#include "Engine/Math/Functions.h"

#define fakeZero -0.000001f
#define epsilon 1.0e-9f

namespace sca2025 {
	namespace Physics {
		bool  CollisionDetection(sRigidBodyState  & i_object_A, sRigidBodyState & i_object_B, float i_dt, Math::sVector &o_normal4A, float &o_collisionTime) {
			
			Math::cMatrix_transformation A2World_rotation(i_object_A.orientation, Math::sVector(0.0f, 0.0f, 0.0f));
			Math::sVector A_x = A2World_rotation * Math::sVector(1.0f, 0.0f, 0.0f);
			Math::sVector A_y = A2World_rotation * Math::sVector(0.0f, 1.0f, 0.0f);
			Math::sVector A_z = A2World_rotation * Math::sVector(0.0f, 0.0f, 1.0f);

			Math::cMatrix_transformation B2World_rotation(i_object_B.orientation, Math::sVector(0.0f, 0.0f, 0.0f));
			Math::sVector B_x = B2World_rotation * Math::sVector(1.0f, 0.0f, 0.0f);
			Math::sVector B_y = B2World_rotation * Math::sVector(0.0f, 1.0f, 0.0f);
			Math::sVector B_z = B2World_rotation * Math::sVector(0.0f, 0.0f, 1.0f);
			
			Math::sVector normal4A;
			float maxCloseTime = -10.0f;
			float minOpenTime = 10.0f;

			bool potentialCollision;
			//check 6 regular axis
			potentialCollision = AxisCheck(i_object_A, i_object_B, A_x, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}
			
			potentialCollision = AxisCheck(i_object_A, i_object_B, A_y, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}
			
			potentialCollision = AxisCheck(i_object_A, i_object_B, A_z, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}
			
			potentialCollision = AxisCheck(i_object_A, i_object_B, B_x, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}

			potentialCollision = AxisCheck(i_object_A, i_object_B, B_y, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}

			potentialCollision = AxisCheck(i_object_A, i_object_B, B_z, i_dt, maxCloseTime, minOpenTime, normal4A);
			if (potentialCollision == false) {
				return false;
			}

			//check axis generated by corss product
			Math::sVector crossProVector;
			//1
			crossProVector = Math::Cross(A_x, B_x);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//2
			crossProVector = Math::Cross(A_x, B_y);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//3
			crossProVector = Math::Cross(A_x, B_z);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//4
			crossProVector = Math::Cross(A_y, B_x);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//5
			crossProVector = Math::Cross(A_y, B_y);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//6
			crossProVector = Math::Cross(A_y, B_z);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//7
			crossProVector = Math::Cross(A_z, B_x);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//8
			crossProVector = Math::Cross(A_z, B_y);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			//9
			crossProVector = Math::Cross(A_z, B_z);
			if (abs(crossProVector.x) > epsilon || abs(crossProVector.y) > epsilon || abs(crossProVector.z) > epsilon) {
				crossProVector.Normalize();
				potentialCollision = AxisCheck(i_object_A, i_object_B, crossProVector, i_dt, maxCloseTime, minOpenTime, normal4A);
				if (potentialCollision == false) {
					return false;
				}
			}
			
			if (maxCloseTime <= minOpenTime) {
				o_normal4A = normal4A;
				o_collisionTime = maxCloseTime;
				return true;
			}

			return false;
		}
		bool AxisCheck(sRigidBodyState  & i_object_A, sRigidBodyState & i_object_B, Math::sVector & i_axis, float i_dt, float & o_maxCloseTime, float & o_minOpenTime, Math::sVector &o_normal4A) {
			float BProjectionOnAxis = 0.0f;

			Math::cMatrix_transformation B2World_rotation(i_object_B.orientation, Math::sVector(0.0f, 0.0f, 0.0f));
			
			Math::sVector BExtendXInWorld = B2World_rotation * Math::sVector(i_object_B.boundingBox.extends.x, 0.0f, 0.0f);
			Math::sVector BExtendYInWorld = B2World_rotation * Math::sVector(0.0f, i_object_B.boundingBox.extends.y, 0.0f);
			Math::sVector BExtendZInWorld = B2World_rotation * Math::sVector(0.0f, 0.0f, i_object_B.boundingBox.extends.z);
			
			float BProjectionX = abs(Math::Dot(BExtendXInWorld, i_axis));
			float BProjectionY = abs(Math::Dot(BExtendYInWorld, i_axis));
			float BProjectionZ = abs(Math::Dot(BExtendZInWorld, i_axis));
			BProjectionOnAxis = BProjectionX + BProjectionY + BProjectionZ;
			//*********************************************************************************
			float AProjectionOnAxis = 0.0f;

			Math::cMatrix_transformation A2World_rotation(i_object_A.orientation, Math::sVector(0.0f, 0.0f, 0.0f));

			Math::sVector AExtendXInWorld = A2World_rotation * Math::sVector(i_object_A.boundingBox.extends.x, 0.0f, 0.0f);
			Math::sVector AExtendYInWorld = A2World_rotation * Math::sVector(0.0f, i_object_A.boundingBox.extends.y, 0.0f);
			Math::sVector AExtendZInWorld = A2World_rotation * Math::sVector(0.0f, 0.0f, i_object_A.boundingBox.extends.z);
			
			float AProjectionX = abs(Math::Dot(AExtendXInWorld, i_axis));
			float AProjectionY = abs(Math::Dot(AExtendYInWorld, i_axis));
			float AProjectionZ = abs(Math::Dot(AExtendZInWorld, i_axis));
			AProjectionOnAxis = AProjectionX + AProjectionY + AProjectionZ;
			//********************************************************************************
			//get B velocity relative to A, assume A is static and B is moving 
			Math::sVector BVelocityInA = i_object_B.velocity - i_object_A.velocity;
			float BVeloInAProjectionOnAxis = Math::Dot(BVelocityInA, i_axis);

			Math::cMatrix_transformation A2World(i_object_A.orientation, i_object_A.position);
			Math::sVector ACenterInWorld = A2World * i_object_A.boundingBox.center;
			Math::cMatrix_transformation B2World(i_object_B.orientation, i_object_B.position);
			Math::sVector BCenterInWorld = B2World * i_object_B.boundingBox.center;

			Math::sVector BCenter2ACenter = ACenterInWorld - BCenterInWorld;
			float distance = Math::Dot(BCenter2ACenter, i_axis);
			float A_extends = AProjectionOnAxis + BProjectionOnAxis;
			float distanceClose = distance - A_extends;
			if (Math::floatEqual(distanceClose, 0.0f)) distanceClose = 0.0f;
			float distanceOpen = distance + A_extends;
			if (Math::floatEqual(distanceOpen, 0.0f)) distanceOpen = 0.0f;

			float closeTime;
			float openTime;
			Math::sVector possibleNormal4A = i_axis;

			if (BVeloInAProjectionOnAxis != 0) {
				closeTime = distanceClose / BVeloInAProjectionOnAxis;
				openTime = distanceOpen / BVeloInAProjectionOnAxis;

				if (closeTime <= 0 && openTime <= 0) {
					return false;
				}
				if (closeTime * openTime < 0) {
					if (BVeloInAProjectionOnAxis > 0) {
						closeTime = fakeZero;
					}
					else {
						openTime = closeTime;
						closeTime = fakeZero;
						//update normal
						possibleNormal4A = -1 * i_axis;
					}
				}
				if (closeTime > openTime) {
					float temp = closeTime;
					closeTime = openTime;
					openTime = temp;
					//update normal 
					possibleNormal4A = -1 * i_axis;
				}
				if (closeTime > i_dt) {
					return false;
				}
			}
			else {
				if (distanceClose < 0 && distanceOpen > 0) {
					closeTime = fakeZero;
					openTime = i_dt;
				}
				else {
					return false;
				}
			}

			//update close and open time
			if (closeTime > o_maxCloseTime) {
				o_maxCloseTime = closeTime;
				//update normal
				o_normal4A = possibleNormal4A;
			}
			if (openTime < o_minOpenTime) o_minOpenTime = openTime;
			
			return true;
		}

		bool FindEarliestCollision(std::vector<GameCommon::GameObject *> & i_allGameObjects, float i_dt, CollisionPair & o_earliestCollision) {
			o_earliestCollision.collisionTime = i_dt;
			bool foundCollision_earliest = false;
			size_t count = i_allGameObjects.size();
			if (count < 2) return false;

			size_t earliest_A, earliest_B;
			for (size_t i = 0; i < count - 1; i++) {
				for (size_t j = i + 1; j < count; j++) {
					Math::sVector colNormal4A;
					float colTime;
					bool collisionFound = CollisionDetection(i_allGameObjects[i]->m_State, i_allGameObjects[j]->m_State, i_dt, colNormal4A, colTime);
					if (collisionFound && colTime == fakeZero) {
						i_allGameObjects[i]->OnOverlap(i_allGameObjects[j]);
						i_allGameObjects[j]->OnOverlap(i_allGameObjects[i]);
					}
					if (collisionFound && colTime != fakeZero) {
						if (colTime < o_earliestCollision.collisionTime) {
							o_earliestCollision.collisionTime = colTime;
							o_earliestCollision.collisionNormal4A = colNormal4A;
							o_earliestCollision.collisionObjects[0] = &i_allGameObjects[i]->m_State;
							o_earliestCollision.collisionObjects[1] = &i_allGameObjects[j]->m_State;
							
							earliest_A = i;
							earliest_B = j;
						}
						foundCollision_earliest = true;
					}
					
				}
			}
			if (foundCollision_earliest) {
				i_allGameObjects[earliest_A]->OnHit(i_allGameObjects[earliest_B]);
				i_allGameObjects[earliest_B]->OnHit(i_allGameObjects[earliest_A]);
			}

			return foundCollision_earliest;
		}

		bool FindRotationCollision(std::vector<GameCommon::GameObject *> & i_allGameObjects, float i_dt, size_t indexOfObjectChecked) {
			//make a copy of phyics state
			sRigidBodyState objectChecked = i_allGameObjects[indexOfObjectChecked]->m_State;
			objectChecked.UpdateOrientation(i_dt);
			objectChecked.velocity = Math::sVector(0.0f, 0.0f, 0.0f);

			size_t numOfObjects = i_allGameObjects.size();
			for (size_t i = 0; i < numOfObjects; i++) {
				if (i != indexOfObjectChecked) {
					//make a copy 
					sRigidBodyState otherObject = i_allGameObjects[i]->m_State;
					otherObject.velocity = Math::sVector(0.0f, 0.0f, 0.0f);

					Math::sVector placeHolderNormal;
					float placeHolderTime;
					bool isCollided = CollisionDetection(objectChecked, otherObject, i_dt, placeHolderNormal, placeHolderTime);
					if (isCollided) return true;
				}
			}

			return false;
		}

	}
}